;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; -*-

(in-package :ags)

(defparameter +confidence-threshold+ 0.75 )
(defparameter +current-sentence+ NIL)
(defvar *word-classes* (make-array 20 :fill-pointer 0 :adjustable t ))

;;;; Regex patterns for the important Julius messages.
(defparameter +shypo+
  "<\\s*SHYPO RANK=\"([^\"]+)\" SCORE=\"([0-9\.-]+)\" GRAM=\"(\d+)\">" )

(defparameter +whypo+
  "\\*<SHYPO WORD=\"([^\"]+)\" CLASSID=\"(\d+)\" PHONE=\"([^\"]+)\" CM=\"([0-9\.]+)\"/>" )
(defparameter +input+
  "<INPUT STATUS=\"([^\"]+)\" TIME=\"(\\d+)\"/>" )
(defparameter +inparm+
  "<INPUTPARAM FRAMES=\"(\\d+)\" MSEC=\"(\\d+)\"/>" )
(defparameter +class-num+ "(\d+)\s+(\w+)" )

(defclass jstate () (
  (recognizing :initform NIL :accessor recog)
  (sent :initform NIL :accessor sent))
  )

(defvar *jstate* (make-instance 'jstate))

(defclass jword () (
  (spell :initarg :spell :accessor spell)
  (class :initarg :class :accessor word-class)
  (phonemes :initarg :phonemes :accessor word-phonemes)
  (confidence :initarg :cm :accessor word-cm)
  ))

(defclass jsent () (
  (rank :initarg :rank :accessor sent-rank)
  (score :initarg :score :accessor sent-score)
  (gram :initarg :gram :accessor sent-gram)
  (words :initform (make-array 10 :fill-pointer 0 :adjustable t )
	 :accessor sent-words)
  ))

;; Extract list of consed spelling and class names and send
;; it to the tree parser.  We leave out the silence markers at
;; the beginning and end.
(defparameter +stopwords+ (list 'NS_B 'NS_E))
(defmethod words-to-parser ((s jsent))
  (let* ((wordlist NIL))
    (dolist (w (sent-words s))
      (let ((name (elt *word-classes* (word-class w))))
	(if (not (member name +stoplist+))
	    (push (cons spell w) name)
	    )
	)
      )
    (agp:parse wordlist)
    )
  )

(defmethod addword (w (s jsent))
  (vector-push-extend w (sent-words s))
  )

(defmethod avgconfidence ((s jsent))
  (let ((total 0))
    (loop for w in (sent-words s) do (setf total (+ total (word-cm w))))
    (floor (/ total (length (sent-words s))))
    ))

(defmethod minconfidence ((s jsent))
  (let ((minimum 1.0))
    (loop for w in (sent-words s) do
	 (if (< (word-cm w) minimum) (setf minimum (word-cm w)))
	 )
    minimum
    ))

;; Load the class-number-to-name table.  This was generated by
;; the mkdfa utility.
(defun load-classes (langmodel)
  "Load word classes"
  (with-open-file (terms (format NIL "~a.term" langmodel))
    (loop for line = (read-line terms)
       while line do
	 (let ((class (cl-utilities:split-sequence
		       '#\Tab
		       (string-trim " " line)))
	       )
	   ;; We internalize the class names in the :AGF namespace
	   ;; because that is where the grammar rules will look
	   ;; for them.
	   (vector-push-extend
	    (intern (cdr class) :agf)
	    *word-classes*)
	   )
	 )
    )
  )

(defun matched-sent (txt)
  (ppcre:register-groups-bind (srank sscore sgram)
   (+shypo+ txt)
   (make-instance 'jsent
		  :rank (parse-integer srank)
		  :score (read-from-string sscore)
		  :gram (parse-integer sgram))
    ))

(defun matched-word (txt)
  (ppcre:register-groups-bind (wspell wclass wph wcm)
   (+shypo+ txt)
   (make-instance 'jword
		  :spell wspell
		  :class (parse-integer wclass)
		  :phonetics wph
		  :cm (read-from-string wcm))
   ))

;; Done receiving a complete sentence.  If we are confident
;; enough in the recognition, we send it to deep grammar analysis.
(defun analyze ()
  (let* ((s +current-sentence+)
	 (mc (minconfidence s)))
    (format T "  min confidence ~,2f~%" mc)
    (if (> mc +confidence-threshold+)
	(words-to-parser s)
	)
    )
  )

;; Process messages from Julius.
(defun jreceive (msg)
  (cond
    ((recog *jstate*)
     (let ((m))
       (cond
	 ((setf m (matched-word msg))
	  (push m (sent-words (sent *jstate*))))

	 ((setf m (matched-sent msg))
	  (progn
	    (format T "Sentence score ~,0f~%" (score m))
	    (setf (sent *jstate) m)))

	 ((search "</SHYPO>" msg)
	  (progn
	    (setf (recog *jstate*) NIL)
	    (analyze)))
	 )))
    ((equal msg "<RECOGOUT>")
     (setf (recog *jstate*) T))

    ((equal msg "</RECOGOUT>")
     (setf (recog *jstate*) NIL))

    (T (format T "Julius ~a~%" msg))
    )
  )

(defvar *jport*)
(defun jconnect ()
  (setq *jport* (agu:connect "127.0.0.1" 10500 'jreceive))
  )

(defun jsend (cmd) (agu:send *jport* cmd))

;;;; Start up Julius, supplying its configuration file.  We also load
;;;; the "term" file that maps the word class numbers to their names.
(defun jstart (confname)
  (load-classes confname)
  (uiop:run-program
   (format NIL "julius -C ~a/~a.jconf"
	   (asdf:system-relative-pathname :agador #p"data/")
	   confname)
   :wait NIL)
  (sleep 2)
  (jconnect)
  )
