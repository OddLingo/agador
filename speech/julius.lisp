;;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; -*-

(in-package :ags)

(defparameter +confidence-threshold+ 0.75 )
(defparameter +current-sentence+ NIL)
(defvar *word-classes* (make-array 20 :fill-pointer 0 :adjustable t ))

;;;; Regex patterns for the important Julius messages.
(defparameter +shypo+
  "<\\s*SHYPO RANK=\"([^\"]+)\" SCORE=\"([0-9\.-]+)\" GRAM=\"(\d+)\">" )

(defparameter +whypo+
  "\\*<SHYPO WORD=\"([^\"]+)\" CLASSID=\"(\d+)\" PHONE=\"([^\"]+)\" CM=\"([0-9\.]+)\"/>" )
(defparameter +input+
  "<INPUT STATUS=\"([^\"]+)\" TIME=\"(\\d+)\"/>" )
(defparameter +inparm+
  "<INPUTPARAM FRAMES=\"(\\d+)\" MSEC=\"(\\d+)\"/>" )
(defparameter +class-num+ "(\\d+)\\s+(\\w+)" )

(defclass jstate () (
  (recognizing :initform NIL :accessor recog)
  (sent :initform NIL :accessor sent))
  )

(defvar *jstate* (make-instance 'jstate))

(defclass jword () (
  (spell :initarg :spell :accessor spell)
  (class :initarg :class :accessor word-class :type fixnum)
  (phonemes :initarg :phonemes :accessor word-phonemes :type string)
  (confidence :initarg :cm :accessor word-cm :type float)
  ))

(defclass jsent () (
  (rank :initarg :rank :accessor sent-rank :type float)
  (score :initarg :score :accessor sent-score :type float)
  (gram :initarg :gram :accessor sent-gram :type fixnum)
  (words :initform (make-array 10 :fill-pointer 0 :adjustable t )
	 :accessor sent-words :type list)
  ))

;; Extract list of consed spelling and class names and send
;; it to the tree parser.  We leave out the silence markers at
;; the beginning and end.
(defparameter +stoplist+ (list 'NS_B 'NS_E))
(defmethod words-to-parser ((s jsent))
  (let* ((wordlist NIL))
    (dolist (w (sent-words s))
      (let ((name (elt *word-classes* (word-class w))))
	(if (not (member name +stoplist+))
	    (push (cons name w) name)
	    )
	)
      )
    (agp:parse wordlist)
    )
  )

(defmethod addword (w (s jsent))
  (vector-push-extend w (sent-words s))
  )

(defmethod avgconfidence ((s jsent))
  (let ((total 0))
    (loop for w in (sent-words s) do (setf total (+ total (word-cm w))))
    (floor (/ total (length (sent-words s))))
    ))

(defmethod minconfidence ((s jsent))
  (let ((minimum 1.0))
    (loop for w in (sent-words s) do
	 (if (< (word-cm w) minimum) (setf minimum (word-cm w)))
	 )
    minimum
    ))

;; Load the class-number-to-name table.  This was generated by
;; the mkdfa utility.
(defun load-classes (langmodel)
  "Load word classes"
  (with-open-file (terms (format NIL "~a.term" langmodel))
    (loop for line = (read-line terms NIL)
       while line do
	 (let ((class (cl-utilities:split-sequence
		       '#\Tab
		       (string-trim " " line)))
	       )
	   ;; We internalize the class names in the :AGF namespace
	   ;; because that is where the grammar rules will look
	   ;; for them.
	   (vector-push-extend
	    (intern (cadr class) :agf)
	    *word-classes*)
	   )
	 )
    )
;  (format T "Classes ~a~%" *word-classes*)
  )

;; Match a <SHYPO that is the start of a sentence report.
(defun matched-sent (jtxt)
  (ppcre:register-groups-bind
   (srank sscore sgram)
   (+shypo+ jtxt :sharedp T)
   (make-instance 'jsent
		  :rank (parse-integer srank)
		  :score (read-from-string sscore)
		  :gram (parse-integer sgram))
    ))

;; Match a <WHYPO that is a word report within a sentence.
(defun matched-word (txt)
  (ppcre:register-groups-bind (wspell wclass wph wcm)
   (+shypo+ txt :sharedp T)
   (make-instance 'jword
		  :spell wspell
		  :class (parse-integer wclass)
		  :phonemes wph
		  :cm (read-from-string wcm))
   ))

;; Done receiving a complete sentence.  If we are confident
;; enough in the recognition, we send it to deep grammar analysis.
(defun analyze ()
  (let* ((s +current-sentence+)
	 (mc (minconfidence s)))
    (format T "  min confidence ~,2f~%" mc)
    (if (> mc +confidence-threshold+)
	(words-to-parser s)
	)
    )
  )

;; Process messages from Julius.
(defun jreceive (msg np)
  (cond
    ((equal "." msg) T)

    ((recog *jstate*)
     (let ((m))
       (cond
	 ((setf m (matched-word msg))
	  (push m (sent-words (sent *jstate*))))

	 ((setf m (matched-sent msg))
	  (progn
	    (format T "Sentence score ~,0f~%" (sent-score m))
	    (setf (sent *jstate*) m)))

	 ((search "</SHYPO>" msg)
	  (progn
	    (setf (recog *jstate*) NIL)
	    (analyze)))
	 )))
    ((equal msg "<RECOGOUT>")
     (setf (recog *jstate*) T))

    ((equal msg "</RECOGOUT>")
     (setf (recog *jstate*) NIL))

    (T (format T "Julius ~a~%" msg))
    )
  )

(defvar *jport*)
(defun jconnect ()
  (setq *jport* (agu:connect
		 "127.0.0.1" 10500
		 :handler 'jreceive
		 :name "Julius"))
  )

;; Send a command to Julius.
(defun jsend (cmd)
  (agu:send *jport* cmd))

;;;; Start up Julius, supplying its configuration file.  We also load
;;;; the "term" file that maps the word class numbers to their names.
(defun jstart (confname)
  (let ((path (asdf:system-relative-pathname :agador #p"data/")))
    (load-classes (format NIL "~a~a" path confname))
    (uiop:launch-program
     (format NIL "julius -C ~a~a.jconf"
	   path
	   confname)
     :output *standard-output*)
    (format T "Julius started~%")
    (sleep 2)
    (jconnect)
  ))
